use alloc::ffi::CString;
use core::fmt;
use core::ptr::NonNull;

use super::AnyClass;
use super::Bool;
use super::Ivar;
use crate::encode::{Encode, Encoding, RefEncode};
use crate::ffi;
use crate::msg_send;
use crate::DowncastTarget;
use crate::Message;

/// An Objective-C object.
///
/// This is slightly different from [`NSObject`] in that it may represent an
/// instance of an _arbitrary_ Objective-C class (e.g. it does not have to be
/// a subclass of `NSObject`, so it can represent other root classes like
/// `NSProxy`).
///
/// `Retained<AnyObject>` is equivalent to Objective-C's `id _Nonnull`.
///
/// This is an opaque type that contains [`UnsafeCell`], and is similar to
/// that in that one can safely access and perform interior mutability on this
/// (both via [`msg_send!`] and through ivars), so long as Rust's mutability
/// rules are upheld, and that data races are avoided.
///
/// Note: This is intentionally neither [`Sync`], [`Send`], [`UnwindSafe`],
/// [`RefUnwindSafe`] nor [`Unpin`], since that is something that may change
/// depending on the specific subclass. For example, `NSAutoreleasePool` is
/// not `Send`, it has to be deallocated on the same thread that it was
/// created. `NSLock` is not `Send` either.
///
/// [`NSObject`]: crate::runtime::NSObject
/// [`UnsafeCell`]: core::cell::UnsafeCell
/// [`msg_send!`]: crate::msg_send
/// [`UnwindSafe`]: std::panic::UnwindSafe
/// [`RefUnwindSafe`]: std::panic::RefUnwindSafe
/// [`Unpin`]: std::marker::Unpin
#[doc(alias = "id")]
#[doc(alias = "objc_object")]
#[repr(C)]
pub struct AnyObject {
    // `isa` field is deprecated, so we don't expose it here.
    //
    // Also, we need this to be a zero-sized, so that the compiler doesn't
    // assume anything about the layout.
    //
    // Use `object_getClass` instead.
    _priv: [u8; 0],
    _p: ffi::OpaqueData,
}

/// Use [`AnyObject`] instead.
#[deprecated = "renamed to `runtime::AnyObject`. Consider using the correct type from the autogenerated `objc2-*` framework crates instead though"]
pub type Object = AnyObject;

unsafe impl RefEncode for AnyObject {
    const ENCODING_REF: Encoding = Encoding::Object;
}

// SAFETY: This is technically slightly wrong, not all objects implement the
// standard memory management methods. But not having this impl would be too
// restrictive, so we'll live with it.
//
// NOTE: AnyObject actually resolves to the class "Object" internally, but we
// don't want to expose that publicly, so we only implement Message here, not
// ClassType.
unsafe impl Message for AnyObject {}

impl AnyObject {
    /// Dynamically find the class of this object.
    ///
    ///
    /// # Panics
    ///
    /// May panic if the object is invalid (which may be the case for objects
    /// returned from unavailable `init`/`new` methods).
    ///
    ///
    /// # Example
    ///
    /// Check that an instance of `NSObject` has the precise class `NSObject`.
    ///
    /// ```
    /// use objc2::ClassType;
    /// use objc2::runtime::NSObject;
    ///
    /// let obj = NSObject::new();
    /// assert_eq!(obj.class(), NSObject::class());
    /// ```
    #[inline]
    #[doc(alias = "object_getClass")]
    pub fn class(&self) -> &'static AnyClass {
        let ptr = unsafe { ffi::object_getClass(self) };
        // SAFETY: The pointer is valid, and it is safe as `'static` since
        // classes are static (can also be verified with the fact that they
        // can be retrieved via `AnyClass::get(self.class().name())`).
        let cls = unsafe { ptr.as_ref() };

        // The class _should_ not be NULL, because the docs only say that if
        // the object is NULL, the class also is; and in practice, certain
        // invalid objects can contain a NULL isa pointer.
        cls.unwrap_or_else(|| panic!("invalid object {:?} (had NULL class)", self as *const Self))
    }

    /// Change the class of the object at runtime.
    ///
    /// Returns the object's previous class.
    ///
    ///
    /// # Safety
    ///
    /// The new class must:
    ///
    /// 1. Be a subclass of the object's current class.
    ///
    /// 2. The subclass must not add any instance variables - importantly, the
    ///    instance size of old and the new classes must be the same.
    ///
    /// 3. Any overridden methods on the new class must be fully compatible
    ///    with the old ones.
    ///
    /// Note that in the general case, where arbitrary parts of the program
    /// may be trying to modify the class of the object concurrently, these
    /// requirements are not actually possible to uphold.
    ///
    /// Since usage of this function is expected to be extremely rare, and
    /// even more so trying to do it concurrently, it is recommended that you
    /// verify that the returned class is what you would expect, and if not,
    /// panic.
    #[inline]
    #[doc(alias = "object_setClass")]
    pub unsafe fn set_class<'s>(this: &Self, cls: &AnyClass) -> &'s AnyClass {
        let this: *const Self = this;
        let this = this as *mut Self;
        let ptr = unsafe { ffi::object_setClass(this, cls) };
        // SAFETY: The class is not NULL because the object is not NULL.
        let old_cls = unsafe { ptr.as_ref().unwrap_unchecked() };
        // TODO: Check the superclass requirement too?
        debug_assert_eq!(
            old_cls.instance_size(),
            cls.instance_size(),
            "old and new class sizes were not equal; this is UB!"
        );
        old_cls
    }

    /// Offset an object pointer to get a pointer to an ivar.
    ///
    ///
    /// # Safety
    ///
    /// The offset must be valid for the given type.
    #[inline]
    pub(crate) unsafe fn ivar_at_offset<T>(ptr: NonNull<Self>, offset: isize) -> NonNull<T> {
        // `offset` is given in bytes, so we convert to `u8` and back to `T`
        let ptr: NonNull<u8> = ptr.cast();
        let ptr: *mut u8 = ptr.as_ptr();
        // SAFETY: The offset is valid
        let ptr: *mut u8 = unsafe { ptr.offset(offset) };
        // SAFETY: The offset operation is guaranteed to not end up computing
        // a NULL pointer.
        let ptr: NonNull<u8> = unsafe { NonNull::new_unchecked(ptr) };
        let ptr: NonNull<T> = ptr.cast();
        ptr
    }

    pub(crate) fn lookup_instance_variable_dynamically(&self, name: &str) -> &'static Ivar {
        let name = CString::new(name).unwrap();
        let cls = self.class();
        cls.instance_variable(&name)
            .unwrap_or_else(|| panic!("ivar {name:?} not found on class {cls}"))
    }

    /// Use [`Ivar::load`] instead.
    ///
    ///
    /// # Safety
    ///
    /// The object must have an instance variable with the given name, and it
    /// must be of type `T`.
    ///
    /// See [`Ivar::load_ptr`] for details surrounding this.
    #[deprecated = "this is difficult to use correctly, use `Ivar::load` instead."]
    pub unsafe fn get_ivar<T: Encode>(&self, name: &str) -> &T {
        let ivar = self.lookup_instance_variable_dynamically(name);
        // SAFETY: Upheld by caller
        unsafe { ivar.load::<T>(self) }
    }

    /// Use [`Ivar::load_mut`] instead.
    ///
    ///
    /// # Safety
    ///
    /// The object must have an instance variable with the given name, and it
    /// must be of type `T`.
    ///
    /// See [`Ivar::load_ptr`] for details surrounding this.
    #[deprecated = "this is difficult to use correctly, use `Ivar::load_mut` instead."]
    pub unsafe fn get_mut_ivar<T: Encode>(&mut self, name: &str) -> &mut T {
        let ivar = self.lookup_instance_variable_dynamically(name);
        // SAFETY: Upheld by caller
        unsafe { ivar.load_mut::<T>(self) }
    }

    pub(crate) fn is_kind_of_class(&self, cls: &AnyClass) -> Bool {
        // SAFETY: The signature is correct.
        //
        // Note that `isKindOfClass:` is not available on every object, but it
        // is still safe to _use_, since the runtime will simply crash if the
        // selector isn't implemented. This is of course not _ideal_, but it
        // works for all of Apple's Objective-C classes, and it's what Swift
        // does.
        //
        // In theory, someone could have made a root object, and overwritten
        // `isKindOfClass:` to do something bogus - but that would conflict
        // with normal Objective-C code as well, so we will consider such a
        // thing unsound by construction.
        unsafe { msg_send![self, isKindOfClass: cls] }
    }

    /// Attempt to downcast the object to a class of type `T`.
    ///
    /// This is the reference-variant. Use [`Retained::downcast`] if you want
    /// to convert a retained object to another type.
    ///
    /// [`Retained::downcast`]: crate::rc::Retained::downcast
    ///
    ///
    /// # Mutable classes
    ///
    /// Some classes have immutable and mutable variants, such as `NSString`
    /// and `NSMutableString`.
    ///
    /// When some Objective-C API signature says it gives you an immutable
    /// class, it generally expects you to not mutate that, even though it may
    /// technically be mutable "under the hood".
    ///
    /// So using this method to convert a `NSString` to a `NSMutableString`,
    /// while not unsound, is generally frowned upon unless you created the
    /// string yourself, or the API explicitly documents the string to be
    /// mutable.
    ///
    /// See Apple's [documentation on mutability][apple-mut] and [on
    /// `isKindOfClass:`][iskindof-doc] for more details.
    ///
    /// [iskindof-doc]: https://developer.apple.com/documentation/objectivec/1418956-nsobject/1418511-iskindofclass?language=objc
    /// [apple-mut]: https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/ObjectMutability/ObjectMutability.html
    ///
    ///
    /// # Generic classes
    ///
    /// Objective-C generics are called "lightweight generics", and that's
    /// because they aren't exposed in the runtime. This makes it impossible
    /// to safely downcast to generic collections, so this is disallowed by
    /// this method.
    ///
    /// You can, however, safely downcast to generic collections where all the
    /// type-parameters are [`AnyObject`].
    ///
    ///
    /// # Panics
    ///
    /// This works internally by calling `isKindOfClass:`. That means that the
    /// object must have the instance method of that name, and an exception
    /// will be thrown (if CoreFoundation is linked) or the process will abort
    /// if that is not the case. In the vast majority of cases, you don't need
    /// to worry about this, since both root objects [`NSObject`] and
    /// `NSProxy` implement this method.
    ///
    /// [`NSObject`]: crate::runtime::NSObject
    ///
    ///
    /// # Examples
    ///
    /// Cast an `NSString` back and forth from `NSObject`.
    ///
    /// ```
    /// use objc2::rc::Retained;
    /// use objc2_foundation::{NSObject, NSString};
    ///
    /// let obj: Retained<NSObject> = NSString::new().into_super();
    /// let string = obj.downcast_ref::<NSString>().unwrap();
    /// // Or with `downcast`, if we do not need the object afterwards
    /// let string = obj.downcast::<NSString>().unwrap();
    /// ```
    ///
    /// Try (and fail) to cast an `NSObject` to an `NSString`.
    ///
    /// ```
    /// use objc2_foundation::{NSObject, NSString};
    ///
    /// let obj = NSObject::new();
    /// assert!(obj.downcast_ref::<NSString>().is_none());
    /// ```
    ///
    /// Try to cast to an array of strings.
    ///
    /// ```compile_fail,E0277
    /// use objc2_foundation::{NSArray, NSObject, NSString};
    ///
    /// let arr = NSArray::from_retained_slice(&[NSObject::new()]);
    /// // This is invalid and doesn't type check.
    /// let arr = arr.downcast_ref::<NSArray<NSString>>();
    /// ```
    ///
    /// This fails to compile, since it would require enumerating over the
    /// array to ensure that each element is of the desired type, which is a
    /// performance pitfall.
    ///
    /// Downcast when processing each element instead.
    ///
    /// ```
    /// use objc2_foundation::{NSArray, NSObject, NSString};
    ///
    /// let arr = NSArray::from_retained_slice(&[NSObject::new()]);
    ///
    /// for elem in arr {
    ///     if let Some(data) = elem.downcast_ref::<NSString>() {
    ///         // handle `data`
    ///     }
    /// }
    /// ```
    #[inline]
    pub fn downcast_ref<T: DowncastTarget>(&self) -> Option<&T> {
        if self.is_kind_of_class(T::class()).as_bool() {
            // SAFETY: Just checked that the object is a class of type `T`.
            //
            // Generic `T` like `NSArray<NSString>` are ruled out by
            // `T: DowncastTarget`.
            Some(unsafe { &*(self as *const Self).cast::<T>() })
        } else {
            None
        }
    }

    // objc_setAssociatedObject
    // objc_getAssociatedObject
    // objc_removeAssociatedObjects
}

impl fmt::Debug for AnyObject {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let ptr: *const Self = self;
        write!(f, "<{}: {:p}>", self.class(), ptr)
    }
}
